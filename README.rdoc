= Babel-icious

A flexible and scalable mapping tool that currently only supports mapping hashes and xml.


== Author

* Chris Wyckoff -- cwyckoff@leadmediapartners.com


== To Do

Add a mapper for JSON.


== Examples

Mappings are set up by calling passing mapping 'coordinates' to a 'config' block on the Mapper class:

 Babelicious::Mapper.config(:foo) do |m|
  
  m.direction :from => :xml, :to => :hash
  
  m.map :from => "foo/bar", :to => "bar/foo"
  m.map :from => "foo/baz", :to => "bar/boo"
  m.map :from => "foo/cuk/coo", :to => "foo/bar/coo"
  m.map :from => "foo/cuk/doo", :to => "doo"
  
 end

The 'config' method takes a symbol as its first argument which serves as an identification tag for that mapping.  The second argument is a block where you indiate the details of your mapping.  This should include a direction indicator and individual mapping 'coordinates'.

 m.direction :from => :xml, :to => :hash

tells the mapper that the source of the mapping will be xml and the target will be a hash.  And the mapping coordinates

 m.map :from => "foo/bar", :to => "bar/foo"

tell the mapper to place the value of element located at "foo/bar" in position "bar/foo".  Here, the slashes indicate nestings for both hashes and xml.  So, given the hash:

 {"foo" => {"bar" => "baz"}}

the slash indicates that "bar" is a nested hash within "foo".  The target xml then should be mapped as

 <bar><foo>baz</foo></bar>

with the value of "bar" from the hash above placed in the nested <foo> tags in the xml.


== Translation

When you want to translate the mappings, simply call:

 Babelicious::Mapper.translate(:foo, source)

passing the tag for the mapping and the actual source you want to translate from.


=== Conditions

You can also qualify your mappings with the methods "unless" and "when".  For example, if you do not want to translate mappings that lack a value, simply add an "unless" method:

  m.map(:from => "foo/bar", :to => "bar/foo").unless(:empty)

if the value at "foo/bar" is empty or nil, "foo/bar" will not be translated.  Additionally, if your qualification is more complicated than a simple empty? or nil?, use the "when" method, which takes a block.  The mapping:

  m.map(:from => "foo/bar", :to => "bar/foo").when do |value|
    value =~ /^M/
  end

will only translate if the value at "foo/bar" begins with a capital "M".


== Customized mappings

=== .to

If your target mapping is conditional, you may use the .to method which takes a block.  The block yields the value of the source mapping for you to use.

   m.from("foo/bar").to do |value|
     if(value == "baz")
       "value/is/baz"
     else
       "value/is/something/else"
     end
   end

Note that the .to method must be used in conjunction with .from, which takes a simple string for the source mapping.

=== .customize

If you have a complex mapping and need to customize it in some way, use the .customize method and pass it a block.  The block yields the source object for you to manipulate.  Let's say you're mapping xml to a hash where the xml source looks like:

  <event><progress><statuses><status><code>Foo</code><message>Bar</message></status></statuses></progress></event>

You need to map statuses so that the output looks like [{"name" => "Foo", "text" => "Bar"}].  Here's how you could customize your mapping:

  m.map(:from => "event/progress/statuses", :to => "event/status_code").customize do |node|
    res = []
    node.elements.map {|nd| res << {"name" => nd.child_content("code"), "text" => nd.child_content("message")}
    res
  end

This mapping would produce:

  {"event" => {"status_code" => [{"name" => "Foo", "text" => "Bar"}]}}

A more common use case is concatenation of nested xml nodes.  Given the following xml:

  <event><institutions><institution>FOO</institution><institution>BAR</institution><institution>BAZ</institution></institutions></event>

You could easily concatentate institutions with the following mapping:

  m.map(:from => "event/institutions", :to => "event/concatenated_institutions").customize do |node|
    node.concatenate_children("|")
  end

which would produce

  {"event" => {"concatenated_institutions" => "FOO|BAR|BAZ"}}

(note: 'concatentate' is a convenience method I've added to the libxml XML::Node object)
